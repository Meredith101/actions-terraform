name: CI/CD

on:
  push:
    branches:
      - main # This workflow will trigger on pushes to the 'main' branch

jobs:
  buildAndTest:
    name: CI Pipeline
    runs-on: ubuntu-latest

    env:
      NODE_ENV: test
      DB_HOST: localhost
      POSTGRES_USER: test
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: test_db

    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Use v4 or later

      - name: Setup Node.js
        uses: actions/setup-node@v4 # Use v4 or later

      - name: Set up PostgreSQL
        uses: Harmon758/postgresql-action@v1 # Use the appropriate version
        with:
          postgresql version: '13'
          postgresql db: ${{ env.POSTGRES_DB }}
          postgresql user: ${{ env.POSTGRES_USER }}
          postgresql password: ${{ env.POSTGRES_PASSWORD }}

      - name: Install Angular dependencies
        run: npm ci

      - name: Run Angular Tests
        run: npm run test:coverage

      - name: Install Express dependencies
        run: npm --prefix ./server ci

      - name: Run Linting
        run: npm --prefix ./server run lint

      - name: Run Migration
        run: npm --prefix ./server run migrate

      - name: Run Express Tests
        run: npm --prefix ./server run coverage

  push_image: # Renamed job for clarity
    runs-on: ubuntu-latest
    needs: buildAndTest # This job depends on 'buildAndTest' successfully completing
    outputs:
      # This output will pass the generated image tag to the 'deploy' job
      image_tag_output: ${{ steps.generate_tag.outputs.dynamic_image_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4 # Use v4 for better OIDC support
        with:
          # IMPORTANT: Replace with your actual AWS Account ID
          # This assumes you have set up an OIDC role for GitHub Actions in AWS IAM
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-oidc-role
          aws-region: eu-west-2

      - name: Get current date for image tag
        id: generate_tag # ID for this step to reference its output
        run: |
          # Generate a timestamp to use as a unique image tag
          TIMESTAMP=$(date +'%Y%m%d%H%M%S')
          echo "Generated TIMESTAMP for image tag: $TIMESTAMP"

          # Export the tag as an environment variable for subsequent steps in THIS job
          echo "IMAGE_TAG=$TIMESTAMP" >> $GITHUB_ENV

          # Export the tag as a step output for other jobs (like 'deploy') to consume
          echo "dynamic_image_tag=$TIMESTAMP" >> $GITHUB_OUTPUT

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2 # Use v2 for better ECR login

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REPOSITORY_NAME: "sams" # Your ECR repository name
          # IMAGE_TAG is now available from the GITHUB_ENV set in the previous step
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          # Construct the full image URI using the ECR registry (from login-ecr) and the tag
          FULL_IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_NAME }}:${{ env.IMAGE_TAG }}"
          LATEST_IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_NAME }}:latest"

          docker build -t "$FULL_IMAGE_URI" . # Build the image (assuming Dockerfile is in repo root)
          docker push "$FULL_IMAGE_URI"       # Push the uniquely tagged image

          docker tag "$FULL_IMAGE_URI" "$LATEST_IMAGE_URI" # Tag the same image as 'latest'
          docker push "$LATEST_IMAGE_URI"                   # Push the 'latest' tag

  deploy:
    runs-on: ubuntu-latest
    needs: push_image # This job needs the 'push_image' job to complete successfully
    env:
      # AWS Region for all AWS CLI/Terraform commands in this job
      AWS_REGION: eu-west-2

      # ECR Details: Ensure this matches what you set in the 'push_image' job
      ECR_REPOSITORY_NAME: "sams"
      # Retrieve the exact image tag from the 'push_image' job's output
      DEPLOY_IMAGE_TAG: ${{ needs.push_image.outputs.image_tag_output }}

      # Elastic Beanstalk Application & Environment Names
      ELASTIC_BEANSTALK_APP_NAME: "sams-app"
      ELASTIC_BEANSTALK_ENV_NAME: "sams-env"

      # S3 Bucket for Elastic Beanstalk deployment bundles
      # IMPORTANT: This bucket should be managed by your Terraform configuration
      S3_DEPLOY_BUCKET_NAME: "meredith-bucket"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-oidc-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          # Use the Terraform version specified in your .terraform-version file or hardcode if preferred
          terraform_version: 1.6.0 # Ensure this matches your local/project requirements

      - name: Create Dockerrun.aws.json and deployment bundle
        id: create_bundle # ID for this step to output the bundle name
        run: |
          # Construct the full ECR Image URI using the tag from the 'push_image' job
          ECR_REGISTRY_URI="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          FULL_ECR_IMAGE_URI="${ECR_REGISTRY_URI}/${{ env.ECR_REPOSITORY_NAME }}:${{ env.DEPLOY_IMAGE_TAG }}"

          # Create the Dockerrun.aws.json file in the repository root
          cat <<EOF > Dockerrun.aws.json
          {
            "AWSEBDockerrunVersion": "1",
            "Image": {
              "Name": "${FULL_ECR_IMAGE_URI}",
              "Update": "true"
            },
            "Ports": [
              {
                "ContainerPort": 80 # <<< IMPORTANT: Adjust this to your Node.js application's actual listening port inside the Docker container (e.g., 80, 3000, 8080)
              }
            ],
            "Volumes": [],
            "Logging": "/var/log/nginx" # Standard Nginx logs, adjust if your Docker image logs differently
          }
          EOF

          # Create a uniquely named .zip bundle containing the Dockerrun.aws.json
          BUNDLE_NAME="${{ env.ELASTIC_BEANSTALK_APP_NAME }}-${{ env.DEPLOY_IMAGE_TAG }}.zip"
          zip -r "$BUNDLE_NAME" Dockerrun.aws.json # Zips the Dockerrun.aws.json file

          # Output the bundle name so subsequent steps (like Terraform) can use it
          echo "bundle_name=$BUNDLE_NAME" >> $GITHUB_OUTPUT

        # This step runs from the default working directory (repository root)

      - name: Upload deployment bundle to S3
        run: |
          # Copy the created .zip bundle to the specified S3 deployment bucket
          aws s3 cp "${{ steps.create_bundle.outputs.bundle_name }}" "s3://${{ env.S3_DEPLOY_BUCKET_NAME }}/"
        # This step also runs from the repository root

      - name: Terraform Init
        id: init
        run: terraform init \
          -backend-config="bucket=${{ env.S3_DEPLOY_BUCKET_NAME }}" \
          -backend-config="key=terraform/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}"
        working-directory: ./terraform # Execute Terraform commands from the 'terraform' directory

      - name: Terraform Plan
        id: plan
        run: terraform plan -input=false -out=tfplan \
          -var="project_name=${{ env.ELASTIC_BEANSTALK_APP_NAME }}" \
          -var="environment=${{ env.ELASTIC_BEANSTALK_ENV_NAME }}" \
          -var="ecr_repository_name=${{ env.ECR_REPOSITORY_NAME }}" \
          -var="app_version_label=${{ env.DEPLOY_IMAGE_TAG }}" \
          -var="db_password=${{ secrets.TF_VAR_db_password }}" \
          -var="vpc_id=${{ secrets.TF_VAR_vpc_id }}" \
          -var="eb_subnet_ids=[${{ secrets.TF_VAR_eb_subnet_ids }}]" \
          -var="s3_bundle_key=${{ steps.create_bundle.outputs.bundle_name }}" # Pass the S3 object key to Terraform
        working-directory: ./terraform

      - name: Terraform Apply
        id: apply
        run: terraform apply -input=false tfplan
        working-directory: ./terraform

      - name: Get Elastic Beanstalk Environment URL
        id: get_url
        run: |
          # Retrieve the environment URL from Terraform outputs
          EB_URL=$(terraform output -raw elastic_beanstalk_environment_url)
          echo "eb_url=${EB_URL}" >> $GITHUB_OUTPUT
        working-directory: ./terraform

      - name: Echo EB URL
        run: |
          echo "Elastic Beanstalk Application deployed successfully!"
          echo "URL: ${{ steps.get_url.outputs.eb_url }}"